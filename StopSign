
power = 500 

game:GetService("RunService").Stepped:connect(function()
game.Players.LocalPlayer.Character.Head.CanCollide = false
game.Players.LocalPlayer.Character["Left Leg"].CanCollide = false
game.Players.LocalPlayer.Character["Right Leg"].CanCollide = false
end)

wait(.1)
local bambam = Instance.new("BodyThrust")
bambam.Parent = game.Players.LocalPlayer.Character.Torso
bambam.Location = game.Players.LocalPlayer.Character.HumanoidRootPart.Position



game.Players.LocalPlayer.Character["Pal Hair"].Handle.Mesh:Destroy()
game.Players.LocalPlayer.Character["Pink Hair"].Handle.Mesh:Destroy()
game.Players.LocalPlayer.Character["Kate Hair"].Handle.Mesh:Destroy()
game.Players.LocalPlayer.Character["LavanderHair"].Handle.Mesh:Destroy()
game.Players.LocalPlayer.Character["Hat1"].Handle.Mesh:Destroy()
game.Players.LocalPlayer.Character["Robloxclassicred"].Handle.Mesh:Destroy()


local Animate = game.Players.LocalPlayer.Character.Animate
HumanDied = false
local count = 1
function Align(Part0, Part1, Position, Angle)
	local AlignPos = Instance.new('AlignPosition', Part1);
	AlignPos.Name = "AliP_" .. count
	AlignPos.ApplyAtCenterOfMass = true;
	AlignPos.MaxForce = 5772000--67752;
	AlignPos.MaxVelocity = math.huge / 9e110;
	AlignPos.ReactionForceEnabled = false;
	AlignPos.Responsiveness = 200;
	AlignPos.RigidityEnabled = true;
	local AlignOri = Instance.new('AlignOrientation', Part1);
	AlignOri.Name = "AliO_" .. count
	AlignOri.MaxAngularVelocity = math.huge / 9e110;
	AlignOri.MaxTorque = 5772000
	AlignOri.PrimaryAxisOnly = false;
	AlignOri.ReactionTorqueEnabled = false;
	AlignOri.Responsiveness = 200;
	AlignOri.RigidityEnabled = true;
	local AttachmentA = Instance.new('Attachment', Part1);
	AttachmentA.Name = "Ath_" .. count
	local AttachmentB = Instance.new('Attachment', Part0);
	AttachmentB.Name = "Ath_" .. count
	AttachmentA.Orientation = Angle or Vector3.new(0, 0, 0)
	AttachmentA.Position = Position or Vector3.new(0, 0, 0)
	AlignPos.Attachment1 = AttachmentA;
	AlignPos.Attachment0 = AttachmentB;
	AlignOri.Attachment1 = AttachmentA;
	AlignOri.Attachment0 = AttachmentB;
	count = count + 1
	spawn(function()
		while wait() do
			Part0.RotVelocity = Vector3.new(0, 0, 0)
			Part0.Velocity = Vector3.new(30, 0, 0)
			Part0.AssemblyLinearVelocity = -Part0.Velocity
		end
	end)

	game:GetService("RunService").Stepped:Connect(function()
		for _, v in pairs(game:GetService("Players").LocalPlayer.Character:GetChildren()) do
			if v:IsA("Part") then
				v.CanCollide = false
			end
			if v:IsA("Accessory") then
				v.Handle.CanCollide = false
			end
		end
	end)
	return {
		AlignPos,
		AlignOri,
		AttachmentA,
		AttachmentB
	}
end
if _G.netted ~= true then
	_G.netted = true
	coroutine.wrap(function()
		settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
		settings().Physics.AllowSleep = false
	end)()
end
game:FindFirstChildOfClass("Players").LocalPlayer["Character"].Archivable = true
local hatnameclone = {}
for _, v in next, game:FindFirstChildOfClass("Players").LocalPlayer["Character"]:GetChildren() do
	if v:IsA("Accessory") then
		if hatnameclone[v.Name] then
			if hatnameclone[v.Name] == "s" then
				hatnameclone[v.Name] = {}
			end
			table.insert(hatnameclone[v.Name], v)
		else
			hatnameclone[v.Name] = "s"
		end
	end
end
for _, v in pairs(hatnameclone) do
	if type(v) == "table" then
		local num = 1
		for _, w in pairs(v) do
			w.Name = w.Name .. num
			num = num + 1
		end
	end
end
hatnameclone = nil
local DeadChar = game:FindFirstChildOfClass("Players").LocalPlayer.Character
local fldr = Instance.new("Folder", game:FindFirstChildOfClass("Players").LocalPlayer["Character"])
fldr.Name = "Dummy"
local CloneChar = DeadChar:Clone()
local ANIMATIONHERE
if CloneChar:FindFirstChild("Animate") then
	ANIMATIONHERE = CloneChar:FindFirstChild("Animate"):Clone()
	CloneChar:FindFirstChild("Animate"):Destroy()
end
if CloneChar:FindFirstChildOfClass("Folder") then
	CloneChar:FindFirstChildOfClass("Folder"):Destroy()
end
if CloneChar.Torso:FindFirstChild("Neck") then
	local Clonessss = CloneChar.Torso:FindFirstChild("Neck"):Clone()
	Clonessss.Part0 = nil
	Clonessss.Part1 = DeadChar.Head
	Clonessss.Parent = DeadChar.Torso
end
CloneChar.Parent = fldr
CloneChar.HumanoidRootPart.CFrame = DeadChar.HumanoidRootPart.CFrame
CloneChar.Humanoid.BreakJointsOnDeath = false
CloneChar.Name = "Dummy"
CloneChar.Humanoid.DisplayDistanceType = "None"
for _, v in next, DeadChar:GetChildren() do
	if v:IsA("Accessory") then
		local topacc = false
		if v.Handle:FindFirstChildOfClass("Weld") then
			v.Handle:FindFirstChildOfClass("Weld"):Destroy()
		end
		v.Handle.Massless = true
		v.Handle.CanCollide = false
		coroutine.wrap(function()
			if topacc then
				local allthings = Align(v.Handle, DeadChar.Torso, Vector3.new(0, 1.5, 0) + (DeadChar.Head[topacc].Position + (v.Handle[topacc].Position * -1)), Vector3.new(0, 0, 0))
				local normaltop = allthings[1].Attachment1
				local alipos = allthings[1]
				local alirot = allthings[2]
				local p0 = v.Handle
				local p1 = DeadChar.Head
				alipos.Parent = CloneChar:FindFirstChild(v.Name).Handle
				alirot.Parent = CloneChar:FindFirstChild(v.Name).Handle
				while true do
					game:GetService("RunService").RenderStepped:wait()
					if HumanDied then
						break
					end
					coroutine.wrap(function()
						if alipos.Attachment1 == normaltop then
							p0.CFrame = p0.CFrame:lerp((((DeadChar.Torso.CFrame * CFrame.new(0, 1.5, 0)) * p1[topacc].CFrame) * p0[topacc].CFrame:inverse()), 1)
						else
							v.Handle.CFrame = v.Handle.CFrame:lerp(alipos.Attachment1.Parent.CFrame * CFrame.new(alipos.Attachment1.Position) * CFrame.Angles(math.rad(alipos.Attachment1.Rotation.X), math.rad(alipos.Attachment1.Rotation.Y), math.rad(alipos.Attachment1.Rotation.Z)), 1)
						end
					end)()
				end
			else
				Align(v.Handle, CloneChar[v.Name].Handle, Vector3.new(0, 0, 0), Vector3.new(0, 0, 0))
			end
		end)()
	end
end
local a = DeadChar.Torso
local b = DeadChar.HumanoidRootPart
local c = DeadChar.Humanoid
a.Parent = game:FindFirstChildOfClass("Workspace")
c.Parent = game:FindFirstChildOfClass("Workspace")
local told = a:Clone()
local told1 = c:Clone()
b["RootJoint"].Part0 = told
b["RootJoint"].Part1 = DeadChar.Head
a.Name = "torso"
a.Neck:Destroy()
told.Parent = DeadChar
told1.Parent = DeadChar
DeadChar.PrimaryPart = told
told1.Health = 0
b:Destroy()
a.Parent = DeadChar
c.Parent = DeadChar
told:Destroy()
told1:Destroy()
a.Name = "Torso"
if CloneChar.Head:FindFirstChildOfClass("Decal") then
	CloneChar.Head:FindFirstChildOfClass("Decal").Transparency = 1
end
if DeadChar:FindFirstChild("Animate") then
	DeadChar:FindFirstChild("Animate"):Destroy()
end
local Collider
function UnCollide()
	if HumanDied then
		Collider:Disconnect();
		return
	end
	for _, Parts in next, DeadChar:GetChildren() do
		if Parts:IsA("BasePart") then
			Parts.CanCollide = false
		end
	end
end
Collider = game:GetService("RunService").Stepped:Connect(UnCollide)
local resetBindable = Instance.new("BindableEvent")
resetBindable.Event:connect(function()
	game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
	resetBindable:Destroy()
	HumanDied = true
	pcall(function()
		game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar
		DeadChar.Head:Destroy()
		DeadChar:FindFirstChildOfClass("Humanoid"):Destroy()
		game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
		if DeadChar:FindFirstChildOfClass("Folder") then
			DeadChar:FindFirstChildOfClass("Folder"):Destroy()
		end
	end)
end)
game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)
coroutine.wrap(function()
	while true do
		game:GetService("RunService").RenderStepped:wait()
		if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChildOfClass("Humanoid") or CloneChar:FindFirstChildOfClass("Humanoid").Health <= 0 and not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChildOfClass("Humanoid") or DeadChar:FindFirstChildOfClass("Humanoid").Health <= 0 then
			HumanDied = true
			pcall(function()
				game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar
				DeadChar.Head:Destroy()
				DeadChar:FindFirstChildOfClass("Humanoid"):Destroy()
				game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
				if DeadChar:FindFirstChildOfClass("Folder") then
					DeadChar:FindFirstChildOfClass("Folder"):Destroy()
				end
			end)
			if resetBindable then
				game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
				resetBindable:Destroy()
			end
			break
		end
	end
end)()


for _, v in pairs(DeadChar:GetChildren()) do
	if v:IsA("BasePart") and v.Name ~= "Head" then
	elseif v:IsA("BasePart") and v.Name == "Head" then
		coroutine.wrap(function()
			while true do
				game:GetService("RunService").RenderStepped:wait()
				if HumanDied then
					break
				end
				v.CFrame = DeadChar.Torso.CFrame * CFrame.new(0, 1.5, 0)
			end
		end)()
	end
end
for _, BodyParts in next, CloneChar:GetDescendants() do
	if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
		BodyParts.Transparency = 1
	end
end
game:GetService("RunService").RenderStepped:wait()
game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
game:FindFirstChildOfClass("Workspace"):FindFirstChildOfClass("Camera").CameraSubject = CloneChar.Humanoid
for _, v in next, DeadChar:GetChildren() do
	if v:IsA("Accessory") then
		if v.Handle:FindFirstChildOfClass("Weld") then
			v.Handle:FindFirstChildOfClass("Weld"):Destroy()
		end
		if v.Handle:FindFirstChildOfClass("AccessoryWeld") then
			v.Handle:FindFirstChildOfClass("AccessoryWeld"):Destroy()
		end
		if v.Handle:FindFirstChildOfClass("BodyBackAttachment") then
			v.Handle:FindFirstChildOfClass("BodyBackAttachment"):Destroy()
		end
	end
end
workspace.FallenPartsDestroyHeight = 0 / 0
local char = workspace[game.Players.LocalPlayer.Name]
local v = char.Torso
for _, v in pairs(v:GetChildren()) do
	if v:IsA("Attachment") and not string.find(v.Name:lower(), "attachment") then
		v:Destroy()
	end
end

local c = char.Dummy.Dummy.Torso
local ath = Instance.new("Attachment", c)
ath.Name = "nil"

local char = workspace[game.Players.LocalPlayer.Name]
for i, hat1 in pairs(char:GetChildren()) do
	if hat1.ClassName == "Accessory" then
		workspace.FallenPartsDestroyHeight = 0 / 0
		local v = hat1.Handle
		for _, v in pairs(v:GetChildren()) do
			if v:IsA("Attachment") and not string.find(v.Name:lower(), "attachment") then
				v:Destroy()
			end
		end
		for i, hat2 in pairs(char.Dummy.Dummy:GetChildren()) do
			if hat2.Name == hat1.Name then
				local c = hat2.Handle
				local ath = Instance.new("Attachment", c)
				ath.Name = "nil"
				coroutine.wrap(function()
					local con
					local function tpmeyes()
						v.CanCollide = false
						v.CFrame = c.CFrame
					end
					con = game["Run Service"].Heartbeat:connect(tpmeyes)
				end)()
			end
		end
	end
end
local e = Animate:Clone()
e.Parent = game.Players.LocalPlayer.Character
local plr = game.Players.LocalPlayer
local mouse = plr:GetMouse()

plr.Character.Torso.BodyThrust:Destroy()
bambam.Force = Vector3.new(power,0,power)

plr.Character["Pal Hair"].Handle.AccessoryWeld:Destroy()

local weld = Instance.new("Weld")
weld.Parent = plr.Character["Left Leg"]
weld.Part0 = plr.Character["Pal Hair"].Handle
weld.Part1 = plr.Character["Left Leg"]
weld.C1 = CFrame.new(0,0,0)*CFrame.Angles(math.rad(90),0,0)

plr.Character["Pink Hair"].Handle.AccessoryWeld:Destroy()

local fasf = Instance.new("Weld")
fasf.Parent = plr.Character["Right Leg"]
fasf.Part0 = plr.Character["Pink Hair"].Handle
fasf.Part1 = plr.Character["Right Leg"]
fasf.C1 = CFrame.new(0,0,0)*CFrame.Angles(math.rad(90),0,0)

plr.Character["LavanderHair"].Handle.AccessoryWeld:Destroy()

local nas = Instance.new("Weld")
nas.Parent = plr.Character["Left Arm"]
nas.Part0 = plr.Character["LavanderHair"].Handle
nas.Part1 = plr.Character["Left Arm"]
nas.C1 = CFrame.new(0,0,0)*CFrame.Angles(math.rad(90),0,0)

plr.Character["Kate Hair"].Handle.AccessoryWeld:Destroy()

local asd = Instance.new("Weld")
asd.Parent = plr.Character["Right Arm"]
asd.Part0 = plr.Character["Kate Hair"].Handle
asd.Part1 = plr.Character["Right Arm"]
asd.C1 = CFrame.new(0,0,0)*CFrame.Angles(math.rad(90),0,0)

plr.Character["Hat1"].Handle.AccessoryWeld:Destroy()

local add = Instance.new("Weld")
add.Parent = plr.Character["Torso"]
add.Part0 = plr.Character["Hat1"].Handle
add.Part1 = plr.Character["Torso"]
add.C1 = CFrame.new(-0.5,0,0)*CFrame.Angles(math.rad(90),0,0)

plr.Character["Robloxclassicred"].Handle.AccessoryWeld:Destroy()

local adds = Instance.new("Weld")
adds.Parent = plr.Character["Torso"]
adds.Part0 = plr.Character["Robloxclassicred"].Handle
adds.Part1 = plr.Character["Torso"]
adds.C1 = CFrame.new(0.5,0,0)*CFrame.Angles(math.rad(90),0,0)

plr.Character["MediHood"].Handle.AccessoryWeld:Destroy()

local Stem = Instance.new("Weld")
Stem.Parent = plr.Character["Head"]
Stem.Part0 = plr.Character["MediHood"].Handle
Stem.Part1 = plr.Character["Head"]
Stem.C1 = CFrame.new(0,0,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))

plr.Character["StopSign"].Handle.AccessoryWeld:Destroy()

local Stem = Instance.new("Weld")
Stem.Parent = plr.Character["Left Arm"]
Stem.Part0 = plr.Character["StopSign"].Handle
Stem.Part1 = plr.Character["Left Arm"]
Stem.C1 = CFrame.new(0,-0.5,-1)*CFrame.Angles(math.rad(0),math.rad(-90),math.rad(60))


game.Players.LocalPlayer.Character["StopSign"].Handle.Touched:Connect(function(Object)
    if Object.Parent:FindFirstChild("Humanoid") then

                            v.CFrame = Object.Parent:FindFirstChild("HumanoidRootPart").CFrame

       end
end)

local objects = game:GetObjects("rbxassetid://7390337728")

objects[1].Parent = game.Players.LocalPlayer.Character


local TweenService = game:GetService("TweenService")
FELOADLIBRARY = {}
loadstring(game:GetObjects("rbxassetid://5209815302")[1].Source)()
local Create = FELOADLIBRARY.Create

script = game.Players.LocalPlayer.Character.Folder


local player = game.Players.LocalPlayer
local char = player.Character
Character = player.Character
Humanoid = Character.Humanoid
RootPart = Character.HumanoidRootPart
Torso = Character.Torso
Head = Character.Head
RightArm = Character['Right Arm']
LeftArm = Character['Left Arm']
RightLeg = Character['Right Leg']
LeftLeg = Character['Left Leg']
RightS = Torso['Right Shoulder']
RootJ = RootPart['RootJoint']
RootJoint = RootJ
LeftS = Torso['Left Shoulder']
RightH = Torso['Right Hip']
LeftH = Torso['Left Hip']
it=Instance.new
local attacking = false
vt=Vector3.new
cf=CFrame.new
local sne = 0
local chaeng = 1
euler=CFrame.fromEulerAnglesXYZ
angles=CFrame.Angles
---im good at shack's coding so stop blaming me you dumbfucks
 rarm = RightArm
larm = LeftArm
IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
------------------
local Chill = false
local sine = sne
for i,v in pairs(Character:children()) do
    if v:IsA("Accessory") then

    end
end
-------------------------------------------------------
--Start Cret's variables stuff--
-------------------------------------------------------
cam = game.Workspace.CurrentCamera
CF = CFrame.new
angles = CFrame.Angles
attack = false
Euler = CFrame.fromEulerAnglesXYZ
Rad = math.rad
IT = Instance.new
BrickC = BrickColor.new
Cos = math.cos
Acos = math.acos
Sin = math.sin
Asin = math.asin
Abs = math.abs
Mrandom = math.random
Floor = math.floor
-------------------------------------------------------
--End Cret's variables stuff--
-------------------------------------------------------
neckcf=cf(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
neckcf2=cf(0, -0.5, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
LeftHC0=cf(-1,-1,0,-0,-0,-1,0,1,0,1,0,0)
LeftHC1=cf(-0.5,1,0,-0,-0,-1,0,1,0,1,0,0)
RightHC0=cf(1,-1,0,0,0,1,0,1,0,-1,-0,-0)
RightHC1=cf(0.5,1,0,0,0,1,0,1,0,-1,-0,-0)
RootCF=euler(-1.57,0,3.14)
necko=neckcf
root = Character.HumanoidRootPart
RH,LH = RightH,LeftH
	local NewInstance = function(instance,parent,properties)
		local inst = Instance.new(instance,parent)
		if(properties)then
			for i,v in next, properties do
				pcall(function() inst[i] = v end)
			end
		end
		return inst;
	end
	local SONG = 1521187414
local sword = script["Stop Sign"]
sword.Parent = char
for i,v in pairs(sword:GetChildren()) do
if v:IsA("UnionOperation") then
v.Anchored = false
end
end



New = function(Object, Parent, Name, Data)
	local Object = Instance.new(Object)
	for Index, Value in pairs(Data or {}) do
		Object[Index] = Value
	end
	Object.Parent = Parent
	Object.Name = Name
	return Object
end
local NewInstance = function(instance,parent,properties)
	local inst = Instance.new(instance,parent)
	if(properties)then
		for i,v in next, properties do
			pcall(function() inst[i] = v end)
		end
	end
	return inst;
end
function WWeld(a, b, acf)
    local we = Instance.new("Weld", a)
    we.Part0 = a
    we.Part1 = b
if acf ~= nil then
    we.C0 = acf
end
return we
end




local music = Instance.new("Sound",char.HumanoidRootPart)
music.SoundId = "rbxassetid://1521187414"
music.Looped = true
music.Pitch = 1
music.Volume = 15
music.TimePosition = 0
music:Play()
local Speed = 65
local storedspeed = 65

function CreateParta(parent,transparency,reflectance,material,brickcolor)
local p = Instance.new("Part")
p.TopSurface = 0
p.BottomSurface = 0
p.Parent = parent
p.Size = Vector3.new(0.1,0.1,0.1)
p.Transparency = transparency
p.Reflectance = reflectance
p.CanCollide = false
p.Locked = true
p.BrickColor = brickcolor
p.Material = material
return p
end

function CreateMesh(parent,meshtype,x1,y1,z1)
local mesh = Instance.new("SpecialMesh",parent)
mesh.MeshType = meshtype
mesh.Scale = Vector3.new(x1*10,y1*10,z1*10)
return mesh
end

function CreateSpecialMesh(parent,meshid,x1,y1,z1)
local mesh = Instance.new("SpecialMesh",parent)
mesh.MeshType = "FileMesh"
mesh.MeshId = meshid
mesh.Scale = Vector3.new(x1,y1,z1)
return mesh
end


function CreateSpecialGlowMesh(parent,meshid,x1,y1,z1)
local mesh = Instance.new("SpecialMesh",parent)
mesh.MeshType = "FileMesh"
mesh.MeshId = meshid
mesh.TextureId = "http://www.roblox.com/asset/?id=269748808"
mesh.Scale = Vector3.new(x1,y1,z1)
mesh.VertexColor = Vector3.new(parent.BrickColor.r, parent.BrickColor.g, parent.BrickColor.b)
return mesh
end

function CreateWeld(parent,part0,part1,C1X,C1Y,C1Z,C1Xa,C1Ya,C1Za,C0X,C0Y,C0Z,C0Xa,C0Ya,C0Za)
local weld = Instance.new("Weld")
weld.Parent = parent
weld.Part0 = part0
weld.Part1 = part1
weld.C1 = CFrame.new(C1X,C1Y,C1Z)*CFrame.Angles(C1Xa,C1Ya,C1Za)
weld.C0 = CFrame.new(C0X,C0Y,C0Z)*CFrame.Angles(C0Xa,C0Ya,C0Za)
return weld
end


Debris = game:GetService("Debris")

--------------
local m = Instance.new("Model",char)
m.Name = MRANDOM(10,403583950)
--------------
local sorb = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
CreateWeld(sorb,RightArm,sorb,0,1,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
local sorb2 = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
CreateWeld(sorb2,LeftArm,sorb2,0,1,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

function clerp(a,b,t) 
local qa = {QuaternionFromCFrame(a)}
local qb = {QuaternionFromCFrame(b)} 
local ax, ay, az = a.x, a.y, a.z 
local bx, by, bz = b.x, b.y, b.z
local _t = 1-t
return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t)) 
end 
 
function QuaternionFromCFrame(cf) 
local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components() 
local trace = m00 + m11 + m22 
if trace > 0 then 
local s = math.sqrt(1 + trace) 
local recip = 0.5/s 
return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5 
else 
local i = 0 
if m11 > m00 then
i = 1
end
if m22 > (i == 0 and m00 or m11) then 
i = 2 
end 
if i == 0 then 
local s = math.sqrt(m00-m11-m22+1) 
local recip = 0.5/s 
return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip 
elseif i == 1 then 
local s = math.sqrt(m11-m22-m00+1) 
local recip = 0.5/s 
return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip 
elseif i == 2 then 
local s = math.sqrt(m22-m00-m11+1) 
local recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip 
end 
end 
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w) 
local xs, ys, zs = x + x, y + y, z + z 
local wx, wy, wz = w*xs, w*ys, w*zs 
local xx = x*xs 
local xy = x*ys 
local xz = x*zs 
local yy = y*ys 
local yz = y*zs 
local zz = z*zs 
return CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy)) 
end
 
function QuaternionSlerp(a, b, t) 
local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4] 
local startInterp, finishInterp; 
if cosTheta >= 0.0001 then 
if (1 - cosTheta) > 0.0001 then 
local theta = math.acos(cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((1-t)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta  
else 
startInterp = 1-t 
finishInterp = t 
end 
else 
if (1+cosTheta) > 0.0001 then 
local theta = math.acos(-cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((t-1)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta 
else 
startInterp = t-1 
finishInterp = t 
end 
end 
return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp 
end

local function CFrameFromTopBack(at, top, back)
local right = top:Cross(back)
return CFrame.new(at.x, at.y, at.z,
right.x, top.x, back.x,
right.y, top.y, back.y,
right.z, top.z, back.z)
end


function QuaternionFromCFrame2(cf)
    local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
    local trace = m00 + m11 + m22
    if trace > 0 then
        local s = math.sqrt(1 + trace)
        local recip = 0.5 / s
        return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
    else
        local i = 0
        if m11 > m00 then
            i = 1
        end
        if m22 > (i == 0 and m00 or m11) then
            i = 2
        end
        if i == 0 then
            local s = math.sqrt(m00 - m11 - m22 + 1)
            local recip = 0.5 / s
            return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
        elseif i == 1 then
            local s = math.sqrt(m11 - m22 - m00 + 1)
            local recip = 0.5 / s
            return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
        elseif i == 2 then
            local s = math.sqrt(m22 - m00 - m11 + 1)
            local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
        end
    end
end
 
function QuaternionToCFrame2(px, py, pz, x, y, z, w)
    local xs, ys, zs = x + x, y + y, z + z
    local wx, wy, wz = w * xs, w * ys, w * zs
    local xx = x * xs
    local xy = x * ys
    local xz = x * zs
    local yy = y * ys
    local yz = y * zs
    local zz = z * zs
    return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
 
function QuaternionSlerp2(a, b, t)
    local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
    local startInterp, finishInterp;
    if cosTheta >= 0.0001 then
        if (1 - cosTheta) > 0.0001 then
            local theta = ACOS(cosTheta)
            local invSinTheta = 1 / SIN(theta)
            startInterp = SIN((1 - t) * theta) * invSinTheta
            finishInterp = SIN(t * theta) * invSinTheta
        else
            startInterp = 1 - t
            finishInterp = t
        end
    else
        if (1 + cosTheta) > 0.0001 then
            local theta = ACOS(-cosTheta)
            local invSinTheta = 1 / SIN(theta)
            startInterp = SIN((t - 1) * theta) * invSinTheta
            finishInterp = SIN(t * theta) * invSinTheta
        else
            startInterp = t - 1
            finishInterp = t
        end
    end
    return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
 
function clerp2(a, b, t)
    local qa = {QuaternionFromCFrame2(a)}
    local qb = {QuaternionFromCFrame2(b)}
    local ax, ay, az = a.x, a.y, a.z
    local bx, by, bz = b.x, b.y, b.z
    local _t = 1 - t
    return QuaternionToCFrame2(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp2(qa, qb, t))
end



ArtificiaLeftHB = Instance.new("BindableEvent", script)
ArtificiaLeftHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")

frame = 1 / 60
tf = 0
allowframeloss = false
tossremainder = false


lastframe = tick()
script.Heartbeat:Fire()


game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)
function swait(num)
	if num == 0 or num == nil then
		ArtificiaLeftHB.Event:wait()
	else
		for i = 0, num do
		ArtificiaLeftHB.Event:wait()
		end
	end
end

function rayCast(Pos, Dir, Max, Ignore)  -- Origin Position , Direction, MaxDistance , IgnoreDescendants
return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore) 
end 
local Mode = "T"
Humanoid.Animator.Parent = nil
RightS.Parent = nil
LeftS.Parent = nil
--welds 
RW, LW=Instance.new("Weld"), Instance.new("Weld") 
RW.Name="Right Shoulder" LW.Name="Left Shoulder"
function NoOutline(Part)
Part.TopSurface,Part.BottomSurface,Part.LeftSurface,Part.RightSurface,Part.FrontSurface,Part.BackSurface = 10,10,10,10,10,10
end 
--
local r = 255
local g = 0
local b = 0
coroutine.resume(coroutine.create(function()
	while wait() do
		for i = 0, 254/5 do
			swait()
			g = g + 5
		end
		for i = 0, 254/5 do
			swait()
			r = r - 5
		end
		for i = 0, 254/5 do
			swait()
			b = b + 5
		end
		for i = 0, 254/5 do
			swait()
			g = g - 5
		end
		for i = 0, 254/5 do
			swait()
			r = r + 5
		end
		for i = 0, 254/5 do
			swait()
			b = b - 5
		end
	end
end)) 


function sphereMK(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = color
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = vt(x1,y1,z1)
local glitchval = math.random(1,255)
if Mode == "R" then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if Mode == "G" then
rng.Color = Color3.new(glitchval,glitchval,glitchval)
end
local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if Mode == "R" then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if Mode == "G" then
rng.Color = Color3.new(glitchval,glitchval,glitchval)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
rng:Destroy()
end))
end

-- 
RW.Name="Right Shoulder"
RW.Part0=char.Torso 
RW.C0=cf(1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.3, 0, -0.5) 
RW.C1=cf(0, 0.5, 0) 
RW.Part1=char["Right Arm"] 
RW.Parent=char.Torso 
-- 
LW.Name="Left Shoulder"
LW.Part0=char.Torso 
LW.C0=cf(-1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.7, 0, 0.8) 
LW.C1=cf(0, 0.5, 0) 
LW.Part1=char["Left Arm"] 
LW.Parent=char.Torso
 
turboli = 0
turboli2 = 0
function sphere(bonuspeed, type, pos, scale, value, color)
local type = type
local rng = Instance.new("Part", char)
rng.Anchored = true
rng.BrickColor = color
rng.CanCollide = false
rng.FormFactor = 3
rng.Name = "Ring"
rng.Material = "Neon"
rng.Size = Vector3.new(1, 1, 1)
rng.Transparency = 0
rng.TopSurface = 0
rng.BottomSurface = 0
rng.CFrame = pos
local rngm = Instance.new("SpecialMesh", rng)
rngm.MeshType = "Sphere"
rngm.Scale = scale
if rainbowmode == true then
rng.Color = Color3.new(r / 255, g / 255, b / 255)
end
local scaler2 = 1
if type == "Add" then
scaler2 = 1 * value
elseif type == "Divide" then
scaler2 = 1 / value
end
coroutine.resume(coroutine.create(function()
for i = 0, 10 / bonuspeed, 0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r / 255, g / 255, b / 255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01 * value / bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01 / value * bonuspeed
end
if chaosmode == true then
rng.BrickColor = BrickColor.random()
end
rng.Transparency = rng.Transparency + 0.01 * bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, scaler2 * bonuspeed)
end
rng:Destroy()
end))
end
function sphere2(bonuspeed,type,pos,scale,value,value2,value3,color)
local type = type
local rng = Instance.new("Part", char)
rng.Anchored = true
if ModeOfGlitch ~= 9 then
rng.BrickColor = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(GetClientProperty(kan,'PlaybackLoudness')/1000,GetClientProperty(kan,'PlaybackLoudness')/1000,GetClientProperty(kan,'PlaybackLoudness')/1000)
end
rng.CanCollide = false
rng.FormFactor = 3
rng.Name = "Ring"
rng.Material = "Neon"
rng.Size = Vector3.new(1, 1, 1)
rng.Transparency = 0
rng.TopSurface = 0
rng.BottomSurface = 0
rng.CFrame = pos
local rngm = Instance.new("SpecialMesh", rng)
rngm.MeshType = "Sphere"
rngm.Scale = scale
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
local scaler2 = 1
local scaler2b = 1
local scaler2c = 1
if type == "Add" then
scaler2 = 1*value
scaler2b = 1*value2
scaler2c = 1*value3
elseif type == "Divide" then
scaler2 = 1/value
scaler2b = 1/value2
scaler2c = 1/value3
end
if ModeOfGlitch == 9 then
coroutine.resume(coroutine.create(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(GetClientProperty(kan,'PlaybackLoudness')/1000,GetClientProperty(kan,'PlaybackLoudness')/1000,GetClientProperty(kan,'PlaybackLoudness')/1000)
else
break
end
end
end))
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
scaler2b = scaler2b - 0.01*value/bonuspeed
scaler2c = scaler2c - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
scaler2b = scaler2b - 0.01/value*bonuspeed
scaler2c = scaler2c - 0.01/value*bonuspeed
end
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
end
rng:Destroy()
end))
end

function Wedge2(bonuspeed,type,pos,scale,value,value2,value3,color)
local type = type
local rng = Instance.new("Part", char)
rng.Anchored = true
if ModeOfGlitch ~= 9 then
rng.BrickColor = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(GetClientProperty(kan,'PlaybackLoudness')/1000,GetClientProperty(kan,'PlaybackLoudness')/1000,GetClientProperty(kan,'PlaybackLoudness')/1000)
end
rng.CanCollide = false
rng.FormFactor = 3
rng.Name = "Ring"
rng.Material = "Neon"
rng.Size = Vector3.new(1, 1, 1)
rng.Transparency = 0
rng.TopSurface = 0
rng.BottomSurface = 0
rng.CFrame = pos
local rngm = Instance.new("SpecialMesh", rng)
rngm.MeshType = "Wedge"
rngm.Scale = scale
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
local scaler2 = 1
local scaler2b = 1
local scaler2c = 1
if type == "Add" then
scaler2 = 1*value
scaler2b = 1*value2
scaler2c = 1*value3
elseif type == "Divide" then
scaler2 = 1/value
scaler2b = 1/value2
scaler2c = 1/value3
end
if ModeOfGlitch == 9 then
coroutine.resume(coroutine.create(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(GetClientProperty(kan,'PlaybackLoudness')/1000,GetClientProperty(kan,'PlaybackLoudness')/1000,GetClientProperty(kan,'PlaybackLoudness')/1000)
else
break
end
end
end))
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
scaler2b = scaler2b - 0.01*value/bonuspeed
scaler2c = scaler2c - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
scaler2b = scaler2b - 0.01/value*bonuspeed
scaler2c = scaler2c - 0.01/value*bonuspeed
end
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
end
rng:Destroy()
end))
end

function slash(bonuspeed,rotspeed,rotatingop,typeofshape,type,typeoftrans,pos,scale,value,color)
local type = type
local rotenable = rotatingop
local rng = Instance.new("Part", char)
rng.Anchored = true
rng.BrickColor = color
rng.CanCollide = false
rng.FormFactor = 3
rng.Name = "Ring"
rng.Material = "Neon"
rng.Size = Vector3.new(1, 1, 1)
rng.Transparency = 0
if typeoftrans == "In" then
rng.Transparency = 1
end
rng.TopSurface = 0
rng.BottomSurface = 0
rng.CFrame = pos
local rngm = Instance.new("SpecialMesh", rng)
rngm.MeshType = "FileMesh"
if typeofshape == "Normal" then
rngm.MeshId = "rbxassetid://662586858"
elseif typeofshape == "Round" then
rngm.MeshId = "rbxassetid://662585058"
end
rngm.Scale = scale
local scaler2 = 1/10
if type == "Add" then
scaler2 = 1*value/10
elseif type == "Divide" then
scaler2 = 1/value/10
end
local randomrot = math.random(1,2)
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed/10
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed/10
end
if rotenable == true then
if randomrot == 1 then
rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(rotspeed*bonuspeed/2),0)
elseif randomrot == 2 then
rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(-rotspeed*bonuspeed/2),0)
end
end
if typeoftrans == "Out" then
rng.Transparency = rng.Transparency + 0.01*bonuspeed
elseif typeoftrans == "In" then
rng.Transparency = rng.Transparency - 0.01*bonuspeed
end
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed/10, 0, scaler2*bonuspeed/10)
end
rng:Destroy()
end))
end

function PixelBlock(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", char)
rng.Anchored = true
rng.BrickColor = color
rng.CanCollide = false
rng.FormFactor = 3
rng.Name = "Ring"
rng.Material = "Neon"
rng.Size = Vector3.new(1, 1, 1)
rng.Transparency = 0
rng.TopSurface = 0
rng.BottomSurface = 0
rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
local rngm = Instance.new("SpecialMesh", rng)
rngm.MeshType = "Brick"
rngm.Scale = vt(x1,y1,z1)
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
local scaler2 = 1
local speeder = FastSpeed/10
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.BrickColor = BrickColor.random()
end
speeder = speeder - 0.01*FastSpeed*bonuspeed/10
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
--rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
end
rng:Destroy()
end))
end

function PixelBlockX(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", char)
rng.Anchored = true
rng.BrickColor = color
rng.CanCollide = false
rng.FormFactor = 3
rng.Name = "Ring"
rng.Material = "Neon"
rng.Size = Vector3.new(1, 1, 1)
rng.Transparency = 0
rng.TopSurface = 0
rng.BottomSurface = 0
rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
local rngm = Instance.new("SpecialMesh", rng)
rngm.MeshType = "Brick"
rngm.Scale = vt(x1,y1,z1)
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
local scaler2 = 1
local speeder = FastSpeed/10
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.BrickColor = BrickColor.random()
end
speeder = speeder - 0.01*FastSpeed*bonuspeed/10
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
end
rng:Destroy()
end))
end

function PixelBlockNeg(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", char)
rng.Anchored = true
rng.BrickColor = color
rng.CanCollide = false
rng.FormFactor = 3
rng.Name = "Ring"
rng.Material = "Neon"
rng.Size = Vector3.new(1, 1, 1)
rng.Transparency = 0
rng.TopSurface = 0
rng.BottomSurface = 0
rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
local rngm = Instance.new("SpecialMesh", rng)
rngm.MeshType = "Brick"
rngm.Scale = vt(x1,y1,z1)
if Mode == "G" then
rng.Color = Color3.new(glitchval,glitchval,glitchval)
end
--[[
coroutine.resume(coroutine.create(function()
	while true do
		swait()
		glitchval = math.random(1,255)
	end
end))]]--
local scaler2 = 0
local speeder = FastSpeed/10
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if Mode == "G" then
rng.Color = Color3.new(glitchval,glitchval,glitchval)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
speeder = speeder + 0.01*FastSpeed*bonuspeed/10
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
--rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
end
rng:Destroy()
end))
end

function block(bonuspeed,type,pos,scale,value,value2,value3,color,color3)
local type = type
local rng = Instance.new("Part", char)
rng.Anchored = true
rng.BrickColor = color
rng.Color = color3
rng.CanCollide = false
rng.FormFactor = 3
rng.Name = "Ring"
rng.Material = "Neon"
rng.Size = Vector3.new(1, 1, 1)
rng.Transparency = 0
rng.TopSurface = 0
rng.BottomSurface = 0
rng.CFrame = pos
local rngm = Instance.new("SpecialMesh", rng)
rngm.MeshType = "Brick"
rngm.Scale = scale
local scaler2 = 1
local scaler2b = 1
local scaler2c = 1
if type == "Add" then
scaler2 = 1*value
scaler2b = 1*value2
scaler2c = 1*value3
elseif type == "Divide" then
scaler2 = 1/value
scaler2b = 1/value2
scaler2c = 1/value3
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
scaler2b = scaler2b - 0.01*value/bonuspeed
scaler2c = scaler2c - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
scaler2b = scaler2b - 0.01/value*bonuspeed
scaler2c = scaler2c - 0.01/value*bonuspeed
end
rng.CFrame = rng.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
end
rng:Destroy()
end))
end

CFuncs = {
Part = {
Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
local Part = Create("Part")({
Parent = Parent,
Reflectance = Reflectance,
Transparency = Transparency,
CanCollide = false,
Locked = true,
BrickColor = BrickColor.new(tostring(BColor)),
Name = Name,
Size = Size,
Material = Material
})
RemoveOutlines(Part)
return Part
end
},
Mesh = {
Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
local Msh = Create(Mesh)({
Parent = Part,
Offset = OffSet,
Scale = Scale
})
if Mesh == "SpecialMesh" then
Msh.MeshType = MeshType
Msh.MeshId = MeshId
end
return Msh
end
},
Mesh = {
Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
local Msh = Create(Mesh)({
Parent = Part,
Offset = OffSet,
Scale = Scale
})
if Mesh == "SpecialMesh" then
Msh.MeshType = MeshType
Msh.MeshId = MeshId
end
return Msh
end
},
Weld = {
Create = function(Parent, Part0, Part1, C0, C1)
local Weld = Create("Weld")({
Parent = Parent,
Part0 = Part0,
Part1 = Part1,
C0 = C0,
C1 = C1
})
return Weld
end
},
Sound = {
Create = function(id, par, vol, pit)
coroutine.resume(coroutine.create(function()
local S = Create("Sound")({
Volume = vol,
Pitch = pit or 1,
SoundId = id,
Parent = par or workspace
})
wait()
S:play()
game:GetService("Debris"):AddItem(S, 10)
end))
end
},

["TimeSound"] = {
Create = function(id, par, vol, pit, timepos) 
coroutine.resume(coroutine.create(function()
local S = Create("Sound"){
Volume = vol,
Name = "EffectSoundo",
Pitch = pit or 1,
SoundId = id,
TimePosition = timepos,
Parent = par or workspace,
}
wait() 
S:play() 
game:GetService("Debris"):AddItem(S, 10)
end))
end;
};
["EchoSound"] = {
Create = function(id, par, vol, pit, timepos,delays,echodelay,fedb,dryl) 
coroutine.resume(coroutine.create(function()
local Sas = Create("Sound"){
Volume = vol,
Name = "EffectSoundo",
Pitch = pit or 1,
SoundId = id,
TimePosition = timepos,
Parent = par or workspace,
}
local E = Create("EchoSoundEffect"){
Delay = echodelay,
Name = "Echo",
Feedback = fedb,
DryLevel = dryl,
Parent = Sas,
}
wait() 
Sas:play() 
game:GetService("Debris"):AddItem(Sas, delays)
end))
end;
};
LongSound = {
Create = function(id, par, vol, pit)
coroutine.resume(coroutine.create(function()
local S = Create("Sound")({
Volume = vol,
Pitch = pit or 1,
SoundId = id,
Parent = par or workspace
})
wait()
S:play()
game:GetService("Debris"):AddItem(S, 30)
end))
end
},
ParticleEmitter = {
Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
local fp = Create("ParticleEmitter")({
Parent = Parent,
Color = ColorSequence.new(Color1, Color2),
LightEmission = LightEmission,
Size = Size,
Texture = Texture,
Transparency = Transparency,
ZOffset = ZOffset,
Acceleration = Accel,
Drag = Drag,
LockedToPart = LockedToPart,
VelocityInheritance = VelocityInheritance,
EmissionDirection = EmissionDirection,
Enabled = Enabled,
Lifetime = LifeTime,
Rate = Rate,
Rotation = Rotation,
RotSpeed = RotSpeed,
Speed = Speed,
VelocitySpread = VelocitySpread
})
return fp
end
},
CreateTemplate = {}
}
function waveEff(bonuspeed,type,typeoftrans,pos,scale,value,value2,color)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = color
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
if typeoftrans == "In" then
rng.Transparency = 1
end
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "FileMesh"
rngm.MeshId = "rbxassetid://20329976"
rngm.Scale = scale
local scaler2 = 1
local scaler2b = 1
if type == "Add" then
scaler2 = 1*value
scaler2b = 1*value2
elseif type == "Divide" then
scaler2 = 1/value
scaler2b = 1/value2
end
local randomrot = math.random(1,2)
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
scaler2b = scaler2b - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
scaler2b = scaler2b - 0.01/value*bonuspeed
end
if randomrot == 1 then
rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(5*bonuspeed/2),0)
elseif randomrot == 2 then
rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(-5*bonuspeed/2),0)
end
if typeoftrans == "Out" then
rng.Transparency = rng.Transparency + 0.01*bonuspeed
elseif typeoftrans == "In" then
rng.Transparency = rng.Transparency - 0.01*bonuspeed
end
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2*bonuspeed)
end
rng:Destroy()
end))
end

function dmg(dude)
	local keptcolor = MAINCOLOR
if dude.Name ~= Character then
local bgf = Instance.new("BodyGyro",dude.Head)
bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(math.rad(-90),0,0)
--[[local val = Instance.new("BoolValue",dude)
val.Name = "IsHit"]]--
local ds = coroutine.wrap(function()
dude:WaitForChild("Head"):BreakJoints()
for i, v in pairs(dude:GetChildren()) do
if v:IsA("Part") or v:IsA("MeshPart") then
v.Name = "DEMINISHED"
CFuncs["Sound"].Create("rbxassetid://763718160", v, 0.75, 1.1)
CFuncs["Sound"].Create("rbxassetid://782353443", v, 1, 1)
--[[for i = 0, 1 do
sphere2(1,"Add",v.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,10,-0.01,BrickColor.new("Bright blue"),BrickColor.new("Bright blue").Color)
end]]--
end
end
wait(0.5)
targetted = nil
CFuncs["Sound"].Create("rbxassetid://62339698", char, 0.25, 0.285)
coroutine.resume(coroutine.create(function()
for i, v in pairs(dude:GetChildren()) do
if v:IsA("Accessory") then
end
if v:IsA("Humanoid") then
v:Destroy()
end
if v:IsA("CharacterMesh") then
v:Destroy()
end
if v:IsA("Model") then
v:Destroy()
end
if v:IsA("Part") or v:IsA("MeshPart") then
for x, o in pairs(v:GetChildren()) do
if o:IsA("Decal") then
o:Destroy()
end
end
coroutine.resume(coroutine.create(function()
v.Material = "Neon"
v.CanCollide = false
v.Anchored = false
local bld = Instance.new("ParticleEmitter",v)
bld.LightEmission = 0.75
bld.Texture = "rbxassetid://2273224484" ---284205403
bld.Color = ColorSequence.new(keptcolor.Color)
bld.Rate = 15
bld.Lifetime = NumberRange.new(1)
bld.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,2,0),NumberSequenceKeypoint.new(0.8,2.25,0),NumberSequenceKeypoint.new(1,0,0)})
bld.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.5,0),NumberSequenceKeypoint.new(0.8,0.75,0),NumberSequenceKeypoint.new(1,1,0)})
bld.Speed = NumberRange.new(2,5)
bld.VelocitySpread = 50000
bld.Rotation = NumberRange.new(-500,500)
bld.RotSpeed = NumberRange.new(-500,500)
        local sbs = Instance.new("BodyPosition", v)
        sbs.P = 3000
        sbs.D = 1000
        sbs.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
        sbs.position = v.Position + Vector3.new(math.random(-2,2),10 + math.random(-2,2),math.random(-2,2))
v.Color = keptcolor.Color
coroutine.resume(coroutine.create(function()
for i = 0, 49 do
swait(1)
v:BreakJoints()
v.Transparency = v.Transparency + 0.02
end
v:BreakJoints()
for i = 0, 4 do
slash(math.random(10,50)/10,3,true,"Round","Add","Out",v.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.0025,0.01),math.random(10,100)/2500,BrickColor.new("White"))
end
block(1,"Add",v.CFrame,vt(0,0,0),0.1,0.1,0.1,keptcolor,keptcolor.Color)
CFuncs["Sound"].Create("rbxassetid://782353117", v, 0.25, 1.2)
CFuncs["Sound"].Create("rbxassetid://1192402877", v, 0.5, 0.75)
bld.Speed = NumberRange.new(10,25)
bld.Drag = 5
bld.Acceleration = vt(0,2,0)
wait(0.5)
bld.Enabled = false
wait(4)
coroutine.resume(coroutine.create(function()
for i = 0, 99 do
swait()
v:Destroy()
dude:Destroy()
end
end))
end))
end))
end
end
end))
end)
ds()
end
end

function FindNearestHead(Position, Distance, SinglePlayer)
	if SinglePlayer then
		return (SinglePlayer.Torso.CFrame.p - Position).magnitude < Distance
	end
	local List = {}
	for i, v in pairs(workspace:GetChildren()) do
		if v:IsA("Model") then
			if v:findFirstChild("Head") then
				if v ~= Character then
					if (v.Head.Position - Position).magnitude <= Distance then
						table.insert(List, v)
					end 
				end 
			end 
		end 
	end
	return List
end



--        RAGDOLL STUFF

 
function recurse(root,callback,i)
    i= i or 0
    for _,v in pairs(root:GetChildren()) do
        i = i + 1
        callback(i,v)
       
        if #v:GetChildren() > 0 then
            i = recurse(v,callback,i)
        end
    end
   
    return i
end
 
function ragdollJoint(character, part0, part1, attachmentName, className, properties)
    attachmentName = attachmentName.."RigAttachment"
    local constraint = Instance.new(className.."Constraint")
    constraint.Attachment0 = part0:FindFirstChild(attachmentName)
    constraint.Attachment1 = part1:FindFirstChild(attachmentName)
    constraint.Name = "RagdollConstraint"..part1.Name
   
    for _,propertyData in next,properties or {} do
        constraint[propertyData[1]] = propertyData[2]
    end
   
    constraint.Parent = character
end
 
function getAttachment0(character, attachmentName)
    for _,child in next,character:GetChildren() do
        local attachment = child:FindFirstChild(attachmentName)
        if attachment then
            return attachment
        end
    end
end
 
function ArtificialHitbox(Part)
    local HITBOX = CreatePart(3, Part, "Metal", 0, 1, "Really black", "Hitbox", Part.Size/2, false)
    HITBOX.CanCollide = true
    HITBOX.CFrame = Part.CFrame
    weldBetween(Part,HITBOX)
end
 
function R15Ragdoll(character,KeepArms)
    character:BreakJoints()
    coroutine.resume(coroutine.create(function()
        recurse(character, function(_,v)
            if v:IsA("Attachment") then
                v.Axis = Vector3.new(0, 1, 0)
                v.SecondaryAxis = Vector3.new(0, 0, 1)
                v.Rotation = Vector3.new(0, 0, 0)
            end
        end)
        for _,child in next,character:GetChildren() do
            if child:IsA("Accoutrement") then
                for _,part in next,child:GetChildren() do
                    if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                        local attachment1 = part:FindFirstChildOfClass("Attachment")
                        local attachment0 = getAttachment0(character,attachment1.Name)
                        if attachment0 and attachment1 then
                            local constraint = Instance.new("HingeConstraint")
                            constraint.Attachment0 = attachment0
                            constraint.Attachment1 = attachment1
                            constraint.LimitsEnabled = true
                            constraint.UpperAngle = 0
                            constraint.LowerAngle = 0
                            constraint.Parent = character
                        end
                        ArtificialHitbox(part)
                    elseif part.Name == "HumanoidRootPart" then
                        part:remove()
                    end
                end
            end
        end
       
        ragdollJoint(character,character.LowerTorso, character.UpperTorso, "Waist", "BallSocket", {
            {"LimitsEnabled",true};
            {"UpperAngle",5};
        })
        if character:FindFirstChild("Head") then
            ragdollJoint(character,character.UpperTorso, character.Head, "Neck", "BallSocket", {
                {"LimitsEnabled",true};
                {"UpperAngle",15};
            })
        end
       
        local handProperties = {
            {"LimitsEnabled", true};
            {"UpperAngle",0};
            {"LowerAngle",0};
        }
        ragdollJoint(character,character.LeftLowerArm, character.LeftHand, "LeftWrist", "Hinge", handProperties)
        ragdollJoint(character,character.RightLowerArm, character.RightHand, "RightWrist", "Hinge", handProperties)
       
        local shinProperties = {
            {"LimitsEnabled", true};
            {"UpperAngle", 0};
            {"LowerAngle", -75};
        }
        ragdollJoint(character,character.LeftUpperLeg, character.LeftLowerLeg, "LeftKnee", "Hinge", shinProperties)
        ragdollJoint(character,character.RightUpperLeg, character.RightLowerLeg, "RightKnee", "Hinge", shinProperties)
       
        local footProperties = {
            {"LimitsEnabled", true};
            {"UpperAngle", 15};
            {"LowerAngle", -45};
        }
        ragdollJoint(character,character.LeftLowerLeg, character.LeftFoot, "LeftAnkle", "Hinge", footProperties)
        ragdollJoint(character,character.RightLowerLeg, character.RightFoot, "RightAnkle", "Hinge", footProperties)
        if KeepArms == true then
            ragdollJoint(character,character.UpperTorso, character.RightUpperArm, "RightShoulder", "BallSocket")
            ragdollJoint(character,character.RightUpperArm, character.RightLowerArm, "RightElbow", "BallSocket")
            ragdollJoint(character,character.UpperTorso, character.LeftUpperArm, "LeftShoulder", "BallSocket")
            ragdollJoint(character,character.LeftUpperArm, character.LeftLowerArm, "LeftElbow", "BallSocket")
        end
        ragdollJoint(character,character.LowerTorso, character.LeftUpperLeg, "LeftHip", "BallSocket")
        ragdollJoint(character,character.LowerTorso, character.RightUpperLeg, "RightHip", "BallSocket")
        Debris:AddItem(character,50)
    end))
end
 
function Ragdoll(Character2,CharTorso,KeepArms)
    coroutine.resume(coroutine.create(function()
        Character2:BreakJoints()
        local hum = Character2:findFirstChild("Humanoid")
        hum:remove()
        local function Scan(ch)
            local e
            for e = 1,#ch do
                Scan(ch[e]:GetChildren())
                if ch[e].ClassName == "Weld" or ch[e].ClassName == "Motor6D" then
                    ch[e]:remove()
                end
            end
        end
        local NEWHUM = IT("Humanoid")
        NEWHUM.Name = "Corpse"
        NEWHUM.Health = 0
        NEWHUM.MaxHealth = 0
        NEWHUM.PlatformStand = true
        NEWHUM.Parent = Character2
        NEWHUM.DisplayDistanceType = "None"
   
        local ch = Character2:GetChildren()
        local i
        for i = 1,#ch do
            if ch[i].Name == "THandle1" or ch[i].Name == "THandle2" then
                ch[i]:remove()
            end
        end
   
        local Torso2 = Character2.Torso
        local movevector = Vector3.new()
   
        if Torso2 then
            movevector = CFrame.new(CharTorso.Position,Torso2.Position).lookVector
            local Head = Character2:FindFirstChild("Head")
            if Head then
                local Neck = Instance.new("Weld")
                Neck.Name = "Neck"
                Neck.Part0 = Torso2
                Neck.Part1 = Head
                Neck.C0 = CFrame.new(0, 1.5, 0)
                Neck.C1 = CFrame.new()
                Neck.Parent = Torso2
   
            end
            local Limb = Character2:FindFirstChild("Right Arm")
            if Limb and KeepArms == true then
   
                Limb.CFrame = Torso2.CFrame * CFrame.new(1.5, 0, 0)
                local Joint = Instance.new("Glue")
                Joint.Name = "RightShoulder"
                Joint.Part0 = Torso2
                Joint.Part1 = Limb
                Joint.C0 = CFrame.new(1.5, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
                Joint.C1 = CFrame.new(-0, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
                Joint.Parent = Torso2
   
                local B = Instance.new("Part")
                B.TopSurface = 0
                B.BottomSurface = 0
                B.formFactor = "Symmetric"
                B.Size = Vector3.new(1, 1, 1)
                B.Transparency = 1
                B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
                B.Parent = Character2
                local W = Instance.new("Weld")
                W.Part0 = Limb
                W.Part1 = B
                W.C0 = CFrame.new(0, -0.5, 0)
                W.Parent = Limb
   
            end
            local Limb = Character2:FindFirstChild("Left Arm")
            if Limb and KeepArms == true then
   
                Limb.CFrame = Torso2.CFrame * CFrame.new(-1.5, 0, 0)
                local Joint = Instance.new("Glue")
                Joint.Name = "LeftShoulder"
                Joint.Part0 = Torso2
                Joint.Part1 = Limb
                Joint.C0 = CFrame.new(-1.5, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
                Joint.C1 = CFrame.new(0, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
                Joint.Parent = Torso2
   
                local B = Instance.new("Part")
                B.TopSurface = 0
                B.BottomSurface = 0
                B.formFactor = "Symmetric"
                B.Size = Vector3.new(1, 1, 1)
                B.Transparency = 1
                B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
                B.Parent = Character2
                local W = Instance.new("Weld")
                W.Part0 = Limb
                W.Part1 = B
                W.C0 = CFrame.new(0, -0.5, 0)
                W.Parent = Limb
   
            end
            local Limb = Character2:FindFirstChild("Right Leg")
            if Limb then
   
                Limb.CFrame = Torso2.CFrame * CFrame.new(0.5, -2, 0)
                local Joint = Instance.new("Glue")
                Joint.Name = "RightHip"
                Joint.Part0 = Torso2
                Joint.Part1 = Limb
                Joint.C0 = CFrame.new(0.5, -1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
                Joint.C1 = CFrame.new(0, 1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
                Joint.Parent = Torso2
   
                local B = Instance.new("Part")
                B.TopSurface = 0
                B.BottomSurface = 0
                B.formFactor = "Symmetric"
                B.Size = Vector3.new(1, 1, 1)
                B.Transparency = 1
                B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
                B.Parent = Character2
                local W = Instance.new("Weld")
                W.Part0 = Limb
                W.Part1 = B
                W.C0 = CFrame.new(0, -0.5, 0)
                W.Parent = Limb
   
            end
            local Limb = Character2:FindFirstChild("Left Leg")
            if Limb then
   
                Limb.CFrame = Torso2.CFrame * CFrame.new(-0.5, -2, 0)
                local Joint = Instance.new("Glue")
                Joint.Name = "LeftHip"
                Joint.Part0 = Torso2
                Joint.Part1 = Limb
                Joint.C0 = CFrame.new(-0.5, -1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
                Joint.C1 = CFrame.new(-0, 1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
                Joint.Parent = Torso2
   
                local B = Instance.new("Part")
                B.TopSurface = 0
                B.BottomSurface = 0
                B.formFactor = "Symmetric"
                B.Size = Vector3.new(1, 1, 1)
                B.Transparency = 1
                B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
                B.Parent = Character2
                local W = Instance.new("Weld")
                W.Part0 = Limb
                W.Part1 = B
                W.C0 = CFrame.new(0, -0.5, 0)
                W.Parent = Limb
   
            end
            --[
            local Bar = Instance.new("Part")
            Bar.TopSurface = 0
            Bar.BottomSurface = 0
            Bar.formFactor = "Symmetric"
            Bar.Size = Vector3.new(1, 1, 1)
            Bar.Transparency = 1
            Bar.CFrame = Torso2.CFrame * CFrame.new(0, 0.5, 0)
            Bar.Parent = Character2
            local Weld = Instance.new("Weld")
            Weld.Part0 = Torso2
            Weld.Part1 = Bar
            Weld.C0 = CFrame.new(0, 0.5, 0)
            Weld.Parent = Torso2
            --]]
        end
        Character2.Parent = workspace
        Debris:AddItem(Character2,50)
   
        return Character2,Torso2
    end))
end


function Damagefunc(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
  if hit.Parent == nil then
    return
  end
  local h = hit.Parent:FindFirstChildOfClass("Humanoid")
  for _, v in pairs(hit.Parent:children()) do
    if v:IsA("Humanoid") then
      h = v
    end
  end
  if h ~= nil and hit.Parent.Name ~= Character.Name and hit.Parent:FindFirstChild("Head") ~= nil then
    if hit.Parent:findFirstChild("DebounceHit") ~= nil and hit.Parent.DebounceHit.Value == true then
      return
    end
    local c = Create("ObjectValue")({
      Name = "creator",
      Value = Player,
      Parent = h
    })
    game:GetService("Debris"):AddItem(c, 0.5)
    if HitSound ~= nil and HitPitch ~= nil then
      CFuncs.Sound.Create(HitSound, hit, math.random(1,4), HitPitch)
    end
    local Damage = math.random(minim, maxim)
    local blocked = false
    local block = hit.Parent:findFirstChild("Block")
    if block ~= nil and block.className == "IntValue" and block.Value > 0 then
      blocked = true
      block.Value = block.Value - 1
      print(block.Value)
    end
    if blocked == false then
      HitHealth = h.Health
      h.MaxHealth = 100
      h.Health = h.Health - Damage
if Chill == true then
	                            if h.Parent:FindFirstChild("Torso") then
                      --  h.Parent:FindFirstChild("Torso").CFrame = h.Parent:FindFirstChild("Torso").CFrame * ANGLES(RAD(2), RAD(0), RAD(0))
                        Ragdoll(h.Parent,Torso,true)
                    elseif h.Parent:FindFirstChild("UpperTorso") then
                        R15Ragdoll(h.Parent,true)
                    end
end
      if HitHealth ~= h.Health and HitHealth ~= 0 and 0 >= h.Health then
        print("gained kill")
                            if h.Parent:FindFirstChild("Torso") then
                      --  h.Parent:FindFirstChild("Torso").CFrame = h.Parent:FindFirstChild("Torso").CFrame * ANGLES(RAD(2), RAD(0), RAD(0))
                        Ragdoll(h.Parent,Torso,true)
                    elseif h.Parent:FindFirstChild("UpperTorso") then
                        R15Ragdoll(h.Parent,true)
                    end
      end
      ShowDamage(Part.CFrame * CFrame.new(0, 0, Part.Size.Z / 2).p + Vector3.new(0, 1.5, 0), -Damage, 1.5, Part.BrickColor.Color)
    else
      h.Health = h.Health - Damage / 2
      ShowDamage(Part.CFrame * CFrame.new(0, 0, Part.Size.Z / 2).p + Vector3.new(0, 1.5, 0), -Damage, 1.5, Part.BrickColor.Color)
    end
    if Type == "Knockdown" then
      local hum = hit.Parent.Humanoid
      hum.PlatformStand = true
      coroutine.resume(coroutine.create(function(HHumanoid)
        swait(1)
        HHumanoid.PlatformStand = false
      end), hum)
      local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
      local bodvol = Create("BodyVelocity")({
        velocity = angle * knockback,
        P = 5000,
        maxForce = Vector3.new(8000, 8000, 8000),
        Parent = hit
      })
      local rl = Create("BodyAngularVelocity")({
        P = 3000,
        maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
        angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
        Parent = hit
      })
      game:GetService("Debris"):AddItem(bodvol, 0.5)
      game:GetService("Debris"):AddItem(rl, 0.5)
    elseif Type == "Normal" then
      local vp = Create("BodyVelocity")({
        P = 500,
        maxForce = Vector3.new(math.huge, 0, math.huge),
        velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05
      })
      if knockback > 0 then
        vp.Parent = hit.Parent.Head
      end
      game:GetService("Debris"):AddItem(vp, 0.5)
    elseif Type == "Up" then
      local bodyVelocity = Create("BodyVelocity")({
        velocity = Vector3.new(0, 20, 0),
        P = 5000,
        maxForce = Vector3.new(8000, 8000, 8000),
        Parent = hit
      })
      game:GetService("Debris"):AddItem(bodyVelocity, 0.5)
      local bodyVelocity = Create("BodyVelocity")({
        velocity = Vector3.new(0, 20, 0),
        P = 5000,
        maxForce = Vector3.new(8000, 8000, 8000),
        Parent = hit
      })
      game:GetService("Debris"):AddItem(bodyVelocity, 1)
    elseif Type == "Leech" then
      local hum = hit.Parent.Humanoid
      if hum ~= nil then
        for i = 0, 2 do
        --  Effects.Sphere.Create(BrickColor.new("Bright red"), hit.Parent.Torso.CFrame * cn(0, 0, 0) * angles(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 15, 1, 0, 5, 0, 0.02)
        end
        Humanoid.Health = Humanoid.Health + 10
      end
    elseif Type == "UpKnock" then
      local hum = hit.Parent.Humanoid
      hum.PlatformStand = true
      if hum ~= nil then
        hitr = true
      end
      coroutine.resume(coroutine.create(function(HHumanoid)
        swait(5)
        HHumanoid.PlatformStand = false
        hitr = false
      end), hum)
      local bodyVelocity = Create("BodyVelocity")({
        velocity = Vector3.new(0, 20, 0),
        P = 5000,
        maxForce = Vector3.new(8000, 8000, 8000),
        Parent = hit
      })
      game:GetService("Debris"):AddItem(bodyVelocity, 0.5)
      local bodyVelocity = Create("BodyVelocity")({
        velocity = Vector3.new(0, 20, 0),
        P = 5000,
        maxForce = Vector3.new(8000, 8000, 8000),
        Parent = hit
      })
      game:GetService("Debris"):AddItem(bodyVelocity, 1)
    elseif Type == "Snare" then
      local bp = Create("BodyPosition")({
        P = 2000,
        D = 100,
        maxForce = Vector3.new(math.huge, math.huge, math.huge),
        position = hit.Parent.Torso.Position,
        Parent = hit.Parent.Torso
      })
      game:GetService("Debris"):AddItem(bp, 1)
    elseif Type == "Slashnare" then
    --  Effects.Block.Create(BrickColor.new("Pastel Blue"), hit.Parent.Torso.CFrame * cn(0, 0, 0), 15*4, 15*4, 15*4, 3*4, 3*4, 3*4, 0.07)
      for i = 1, math.random(4, 5) do
     -- Effects.Sphere.Create(BrickColor.new("Teal"), hit.Parent.Torso.CFrame * cn(math.random(-5, 5), math.random(-5, 5), math.random(-5, 5)) * angles(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 15, 1, 0, 5, 0, 0.02)
      end
      local bp = Create("BodyPosition")({
        P = 2000,
        D = 100,
        maxForce = Vector3.new(math.huge, math.huge, math.huge),
        position = hit.Parent.Torso.Position,
        Parent = hit.Parent.Torso
      })
      game:GetService("Debris"):AddItem(bp, 1)
    elseif Type == "Spike" then
     -- CreateBigIceSword(hit.Parent.Torso.CFrame)
      local bp = Create("BodyPosition")({
        P = 2000,
        D = 100,
        maxForce = Vector3.new(math.huge, math.huge, math.huge),
        position = hit.Parent.Torso.Position,
        Parent = hit.Parent.Torso
      })
      game:GetService("Debris"):AddItem(bp, 1)
    elseif Type == "Freeze" then
      local BodPos = Create("BodyPosition")({
        P = 50000,
        D = 1000,
        maxForce = Vector3.new(math.huge, math.huge, math.huge),
        position = hit.Parent.Torso.Position,
        Parent = hit.Parent.Torso
      })
      local BodGy = Create("BodyGyro")({
        maxTorque = Vector3.new(400000, 400000, 400000) * math.huge,
        P = 20000,
        Parent = hit.Parent.Torso,
        cframe = hit.Parent.Torso.CFrame
      })
      hit.Parent.Torso.Anchored = true
      coroutine.resume(coroutine.create(function(Part)
        swait(1.5)
        Part.Anchored = false
      end), hit.Parent.Torso)
      game:GetService("Debris"):AddItem(BodPos, 3)
      game:GetService("Debris"):AddItem(BodGy, 3)
    end
    local debounce = Create("BoolValue")({
      Name = "DebounceHit",
      Parent = hit.Parent,
      Value = true
    })
    game:GetService("Debris"):AddItem(debounce, Delay)
    c = Instance.new("ObjectValue")
    c.Name = "creator"
    c.Value = Player
    c.Parent = h
    game:GetService("Debris"):AddItem(c, 0.5)
  end
end
function RemoveOutlines(part)
  part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreatePart(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
  local Part = Create("Part")({
    Parent = Parent,
    Reflectance = Reflectance,
    Transparency = Transparency,
    CanCollide = false,
    Locked = true,
    BrickColor = BrickColor.new(tostring(BColor)),
    Name = Name,
    Size = Size,
    Material = Material
  })
  Part.CustomPhysicalProperties = PhysicalProperties.new(0.001, 0.001, 0.001, 0.001, 0.001)
  RemoveOutlines(Part)
  return Part
end
function ShowDamage(Pos, Text, Time, Color)
coroutine.resume(coroutine.create(function()
  local Rate = 0.03333333333333333
  local Pos = Pos or Vector3.new(0, 0, 0)
  local Text = Text or ""
  local Color = Color or Color3.new(1, 0, 1)
  local EffectPart = CreatePart(Character, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
  EffectPart.Anchored = true
  EffectPart.CFrame = CFrame.new(Pos)
  local BillboardGui = Create("BillboardGui")({
    Size = UDim2.new(6, 0, 6, 0),
    Adornee = EffectPart,
    Parent = EffectPart,
	AlwaysOnTop=true,
	Active=true
  })
  local TextLabel = Create("TextLabel")({
    BackgroundTransparency = 1,
	AnchorPoint=Vector2.new(.5,.5),
    Position = UDim2.new(.5, 0, .5, 0),
    Size = UDim2.new(1, 0, 1, 0),
    Text = "STOP",
    TextColor3 = BRICKC'Institutional white'.Color,
   	TextStrokeColor3 = Color3.new(1,0,0),
	TextStrokeTransparency=0,
    TextScaled = true,
    Font = "Arcade",
    Parent = BillboardGui,
	ZIndex=4,
  })
local raise=.2
local rot=math.random(-10,10)/15
local aaa=math.random(-360,360)
local bbb=math.random(-360,360)
for aaa=0,2.7,.01 do
swait()
raise=raise-.008
TextLabel.Rotation = TextLabel.Rotation+math.random(-2,2)
TextLabel.TextTransparency=aaa
TextLabel.TextStrokeTransparency=aaa
EffectPart.Position=EffectPart.Position+Vector3.new(math.random(-raise,raise),math.random(-raise,raise),math.random(-raise,raise))
end
wait(3)
BillboardGui:Remove()
EffectPart:Remove()
end))
end
function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
  for _, c in pairs(workspace:children()) do
    local hum = c:findFirstChildOfClass("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Head")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= player.Name then
          Damagefunc(head, head, mindam, maxdam, knock, Type, RootPart, 0.1, "rbxassetid://500281906", 1)
        end
      end
    end
  end
end

function MagniDamageWithEffect(Part, magni, mindam, maxdam, knock, Type)
  for _, c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Torso")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= player.Name then
	--MagicBlock(BrickColor.new("Pastel light blue"),head.CFrame,5,5,5,1,1,1,0.05)
          Damagefunc(head, head, mindam, maxdam, knock, Type, RootPart, 0.1, "rbxassetid://500281906", 1)
        end
      end
    end
  end
end
--[[
MagniDamage(Torso, 13, 2,6, 0, "Normal",153092213)
]]--
function test()
	attacking = true
	  for i = 0, 0.8, 0.1 do
swait()
		RH.C0=clerp(RH.C0,cf(1,-.5,-.5)*angles(math.rad(-35),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),.2)
		LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),.2)
		RootJoint.C0=clerp(RootJoint.C0,RootCF*angles(math.rad(-7),0,math.rad(25)),.2)
		Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(0,0,math.rad(-25)),.2)
RW.C0=clerp(RW.C0,cf(1.05,0.5,-0.5)*angles(math.rad(130),math.rad(0),math.rad(-30)),.6)
LW.C0=clerp(LW.C0,cf(-1.05,0.5,-0.5)*angles(math.rad(130),math.rad(0),math.rad(30)),.6)
	end
	MagniDamage(sword.Sign, 15, 35,42, 0, "Normal",153092213)
  for i = 0, 0.5, 0.1 do
swait()
		RH.C0=clerp(RH.C0,cf(1,-1,-.5)*angles(math.rad(25),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),.6)
		LH.C0=clerp(LH.C0,cf(-1,-1.1,0)*angles(math.rad(-5),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),.4)
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-.2,0)*angles(math.rad(38),0,0),.6)
		Torso.Neck.C0=clerp(Torso.Neck.C0,necko,.4)
RW.C0=clerp(RW.C0,cf(1.05,0.5,-0.5)*angles(math.rad(10),math.rad(0),math.rad(-30)),.6)
LW.C0=clerp(LW.C0,cf(-1.05,0.5,-0.5)*angles(math.rad(10),math.rad(0),math.rad(30)),.6)
end
attacking = false
end


function test2()
	attacking = true
		      CFuncs.Sound.Create("rbxassetid://1809280396", char, 6, 1)
		wait(2.11)
	  for i = 0, 3, 0.1 do
swait()
		RH.C0=clerp(RH.C0,cf(1,-.5,-.5)*angles(math.rad(-35),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),.2)
		LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),.2)
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,2)*angles(math.rad(-7),0,math.rad(25)),.2)
		Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(0,0,math.rad(-25)),.2)
RW.C0=clerp(RW.C0,cf(1.05,0.5,-0.5)*angles(math.rad(130),math.rad(0),math.rad(-30)),.6)
LW.C0=clerp(LW.C0,cf(-1.05,0.5,-0.5)*angles(math.rad(130),math.rad(0),math.rad(30)),.6)
	end
  for i = 0, 2, 0.1 do
swait()
		RH.C0=clerp(RH.C0,cf(1,-1,-.5)*angles(math.rad(25),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),.6)
		LH.C0=clerp(LH.C0,cf(-1,-1.1,0)*angles(math.rad(-5),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),.4)
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-0.6)*angles(math.rad(76),0,0),.6)
		Torso.Neck.C0=clerp(Torso.Neck.C0,necko,.4)
RW.C0=clerp(RW.C0,cf(1.05,0.5,-0.5)*angles(math.rad(10),math.rad(0),math.rad(-30)),.6)
LW.C0=clerp(LW.C0,cf(-1.05,0.5,-0.5)*angles(math.rad(10),math.rad(0),math.rad(30)),.6)
end
	sphere2(1,"Add",Torso.CFrame,vt(10,10,10),3,3,3,BrickColor.new("New Yeller"),BrickColor.new("New Yeller").Color)
sphere2(1.5,"Add",Torso.CFrame,vt(10,10,10),3.1,3.1,3.1,BrickColor.new("Really red"),BrickColor.new("Really red").Color)
sphere2(2,"Add",Torso.CFrame,vt(10,10,10),3.2,3.2,3.2,BrickColor.new("Really red"),BrickColor.new("Really red").Color)
	MagniDamage(sword.Sign, 75, 125,976, 0, "Normal",153092213)
attacking = false
end

function test3()
	attacking = true
	  for i = 0, 6, 0.1 do
swait()
swordweld.C0 = CFrame.new(0,-0.51,0.726)*CFrame.Angles(math.rad(sine*23),math.rad(-0),math.rad(0))
RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(2 - 2 * math.cos(sine / 32))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(2 + 2 * math.cos(sine / 32))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.02 + 0.02 * math.cos(sine / 32),-0.1 + 0.1 * math.cos(sine / 20))*angles(math.rad(2 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0 - 1 * math.cos(sine / 44))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-23 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(-32 + 2 * math.cos(sine / 53))),.1)
		RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(134 + 3 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(19 + 2 * math.cos(sine / 45))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),-0)*angles(math.rad(2 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(-21 - 4 * math.cos(sine / 45))),.1)
	end
			      CFuncs.Sound.Create("rbxassetid://500281906", char, 6, 1)
  for i = 0, 5.25, 0.1 do
swait()
swordweld.C0 = CFrame.new(0,-0.51,0.726)*CFrame.Angles(math.rad(90),math.rad(-0),math.rad(0))
RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(21 - 2 * math.cos(sine / 32))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-21 + 2 * math.cos(sine / 32))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.02 + 0.02 * math.cos(sine / 32),-0.1 + 0.1 * math.cos(sine / 20))*angles(math.rad(21 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0 - 1 * math.cos(sine / 44))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-21 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(2 + 2 * math.cos(sine / 53))),.1)
		RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(104 + 3 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(19 + 2 * math.cos(sine / 45))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),-0)*angles(math.rad(2 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(-21 - 4 * math.cos(sine / 45))),.1)
end
attacking = false
end

mouse.KeyDown:connect(function(key)		---------------------ATTACKS--------------------------
				if key == "z" and attacking == false then
					test()
				end
end)
mouse.KeyDown:connect(function(key)
				if key == "x" and attacking == false then
					test2()
				end
end)
mouse.KeyDown:connect(function(key)
			if key == "t" and attacking == false then
					test3()
				end
end)
					----------------TAUNTS-----------------------------------------
mouse.KeyDown:connect(function(key)
	
if key == "p" and attacking == false then
		if Chill == false then
Chill = true
		elseif Chill == true then
			Chill = false
		end
	end
end)


while true do
	swait()
	sne = sne + chaeng
timepoz = music.TimePosition
music.SoundId = "rbxassetid://"..SONG
music.Volume = 3
if music.Parent ~= char.HumanoidRootPart then
music = Instance.new("Sound",char.HumanoidRootPart)
music.SoundId = "rbxassetid://"..SONG
music.Looped = true
music.Pitch = 1
music.Volume = 3
music.TimePosition = timepoz
music:Resume()	
end
for i,v in pairs(Character:children()) do
    if v:IsA("Accessory") then
    end
end
sine = sne
char.Humanoid.WalkSpeed = Speed
char.Humanoid.JumpPower = 50
local TorsoVelocity=(RootPart.Velocity*Vector3.new(1,0,1)).magnitude 
local velderp=RootPart.Velocity.y
hitfloor,posfloor=rayCast(RootPart.Position,(CFrame.new(RootPart.Position,RootPart.Position - Vector3.new(0,1,0))).lookVector,4,Character)
if RootPart.Velocity.y > 1 and hitfloor==nil then 
ANIMATION="Jump"
if attacking==false then
RightH.C0=clerp(RightH.C0,cf(1,-0.35 - 0.05 * math.cos(sne / 25),-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(-20)),.1)
LeftH.C0=clerp(LeftH.C0,cf(-1,-1 - 0.05 * math.cos(sne / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(20)),.1)
RootJ.C0=clerp(RootJ.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sne / 25))*angles(math.rad(-10),math.rad(0),math.rad(0)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,neckcf*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.1)
RW.C0=clerp(RW.C0,cf(1.45,0.5 + 0.1 * math.cos(sne / 25),0)*angles(math.rad(-5),math.rad(0),math.rad(25)),.1)
LW.C0=clerp(LW.C0,cf(-1.45,0.5 + 0.1 * math.cos(sne / 25),0)*angles(math.rad(-5),math.rad(0),math.rad(-25)),.1)
end
elseif RootPart.Velocity.y < -1 and hitfloor==nil then 
ANIMATION="Fall"
if attacking==false then
RH.C0=clerp(RH.C0,cf(1,-0.35 - 0.05 * math.cos(sine / 25),-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(-20)),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(20)),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 25))*angles(math.rad(10),math.rad(0),math.rad(0)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(2.5),math.rad(0),math.rad(0)),.1)
RW.C0=clerp(RW.C0,cf(1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-15),math.rad(0),math.rad(55)),.1)
LW.C0=clerp(LW.C0,cf(-1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-15),math.rad(0),math.rad(-55)),.1)
end
elseif TorsoVelocity<1 and hitfloor~=nil then
ANIMATION="Idle"
if attacking==false then
    Stem.C1 = CFrame.new(0,-0.5,-1)*CFrame.Angles(math.rad(0),math.rad(-90),math.rad(60))

RH.C0=clerp(RH.C0,cf(1,-0.32 - 0.1 * math.cos(sine / 20),-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(41 - 2 * math.cos(sine / 32))),.1)
LH.C0=clerp(LH.C0,cf(-1,-0.9 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(12 + 2 * math.cos(sine / 32))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.02 + 0.02 * math.cos(sine / 32),-0.8 + 0.1 * math.cos(sine / 20))*angles(math.rad(38 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0 - 1 * math.cos(sine / 44))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-21 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
		RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(134 + 3 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(19 + 2 * math.cos(sine / 45))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),-0)*angles(math.rad(2 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(-21 - 4 * math.cos(sine / 45))),.1)
end
elseif TorsoVelocity>2 and TorsoVelocity<22 and hitfloor~=nil then
ANIMATIONATION="Walk"
if attacking==false then
    Stem.C1 = CFrame.new(2,-0.5,0)*CFrame.Angles(math.rad(0),math.rad(-180),math.rad(90))

RightH.C0=clerp(RightH.C0,cf(1,-1 - 0.15 * math.cos(sne / 17),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0 + 45 * math.cos(sne / 17))),.1)
LeftH.C0=clerp(LeftH.C0,cf(-1,-1 - 0.15 * math.cos(sne / 17),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0 + 45 * math.cos(sne / 17))),.1)
RootJ.C0=clerp(RootJ.C0,RootCF*cf(0,-0.3,-0.05 + 0.15 * math.cos(sne / 17))*angles(math.rad(11 - 6 * math.cos(sne / 17)),math.rad(0 + RootPart.RotVelocity.Y*1.5),math.rad(0 - RootPart.RotVelocity.Y - 1 * math.cos(sne / 17))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,neckcf*angles(math.rad(-6 + 2 * math.cos(sne / 17)),math.rad(0 + RootPart.RotVelocity.Y*1.5),math.rad(0 - Head.RotVelocity.Y*1.5 + 1 * math.cos(sne / 17))),.1)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(50 * math.cos(sne / 17)),math.rad(-1),math.rad(7 + 4 * math.cos(sne / 17))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-50 * math.cos(sne / 17)),math.rad(1),math.rad(-7 - 4 * math.cos(sne / 17))),.1)
end
elseif TorsoVelocity>=22 and hitfloor~=nil then
ANIMATIONATION="Run"
if attacking==false then
RightH.C0=clerp(RightH.C0,cf(1,-1 - 0.15 * math.cos(sne / 12),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(-1*math.cos(sine/6)),math.rad(0 + 98 * math.cos(sne / 5))),.1)
LeftH.C0=clerp(LeftH.C0,cf(-1,-1 - 0.15 * math.cos(sne / 12),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(-1*math.cos(sine/6)),math.rad(0 + 98 * math.cos(sne / 5))),.1)
RootJ.C0=clerp(RootJ.C0,RootCF*cf(0,-0.3,-0.05 + 0.15 * math.cos(sne / 12))*angles(math.rad(-22 - 2 * math.cos(sne / 12)),math.rad(0 + RootPart.RotVelocity.Y*1.5),math.rad(0 - RootPart.RotVelocity.Y - 1 * math.cos(sne / 23))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,neckcf*angles(math.rad(-6 + 2 * math.cos(sne / 12)),math.rad(0 + RootPart.RotVelocity.Y*1.5),math.rad(0 - Head.RotVelocity.Y*1.5 + 1 * math.cos(sne / 12))),.1)
		RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 12),0)*angles(math.rad(65 + 0.01 * math.cos(sine / 67)),math.rad(90 - 2 * math.cos(sine / 12)),math.rad(2 + 1 * math.cos(sine / 6))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 12),0)*angles(math.rad(65 + 0.01 * math.cos(sine / 67)),math.rad(4 - 3 * math.cos(sine / 12)),math.rad(-1 - 2 * math.cos(sine / 6))),.1)
end
end
end
